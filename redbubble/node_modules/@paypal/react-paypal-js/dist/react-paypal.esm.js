function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

import React, { createContext, useContext, useReducer, useEffect, useRef, useState } from 'react';
/*!
 * paypal-js v3.1.7 (2021-04-10T17:17:47.380Z)
 * Copyright 2020-present, PayPal, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function findScript(url, attributes) {
  var currentScript = document.querySelector("script[src=\"".concat(url, "\"]"));
  if (currentScript === null) return null;
  var nextScript = createScriptElement(url, attributes); // ignore the data-uid-auto attribute that gets auto-assigned to every script tag

  var currentScriptDataset = Object.assign({}, currentScript.dataset);
  delete currentScriptDataset.uidAuto; // check if the new script has the same number of data attributes

  if (Object.keys(currentScriptDataset).length !== Object.keys(nextScript.dataset).length) {
    return null;
  }

  var isExactMatch = true; // check if the data attribute values are the same

  Object.keys(currentScriptDataset).forEach(function (key) {
    if (currentScriptDataset[key] !== nextScript.dataset[key]) {
      isExactMatch = false;
    }
  });
  return isExactMatch ? currentScript : null;
}

function insertScriptElement(_ref) {
  var url = _ref.url,
      attributes = _ref.attributes,
      onSuccess = _ref.onSuccess,
      onError = _ref.onError;
  var newScript = createScriptElement(url, attributes);
  newScript.onerror = onError;
  newScript.onload = onSuccess;
  document.head.insertBefore(newScript, document.head.firstElementChild);
}

function processOptions(options) {
  var sdkBaseURL = "https://www.paypal.com/sdk/js";

  if (options.sdkBaseURL) {
    sdkBaseURL = options.sdkBaseURL;
    delete options.sdkBaseURL;
  }

  var processedMerchantIDAttributes = processMerchantID(options["merchant-id"], options["data-merchant-id"]);
  var newOptions = Object.assign({}, options, processedMerchantIDAttributes);

  var _Object$keys$filter$r = Object.keys(newOptions).filter(function (key) {
    return typeof newOptions[key] !== "undefined" && newOptions[key] !== null && newOptions[key] !== "";
  }).reduce(function (accumulator, key) {
    var value = newOptions[key].toString();

    if (key.substring(0, 5) === "data-") {
      accumulator.dataAttributes[key] = value;
    } else {
      accumulator.queryParams[key] = value;
    }

    return accumulator;
  }, {
    queryParams: {},
    dataAttributes: {}
  }),
      queryParams = _Object$keys$filter$r.queryParams,
      dataAttributes = _Object$keys$filter$r.dataAttributes;

  return {
    url: "".concat(sdkBaseURL, "?").concat(objectToQueryString(queryParams)),
    dataAttributes: dataAttributes
  };
}

function objectToQueryString(params) {
  var queryString = "";
  Object.keys(params).forEach(function (key) {
    if (queryString.length !== 0) queryString += "&";
    queryString += key + "=" + params[key];
  });
  return queryString;
}

function createScriptElement(url) {
  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var newScript = document.createElement("script");
  newScript.src = url;
  Object.keys(attributes).forEach(function (key) {
    newScript.setAttribute(key, attributes[key]);

    if (key === "data-csp-nonce") {
      newScript.setAttribute("nonce", attributes["data-csp-nonce"]);
    }
  });
  return newScript;
}

function processMerchantID(merchantID, dataMerchantID) {
  var newMerchantID = "";
  var newDataMerchantID = "";

  if (Array.isArray(merchantID)) {
    if (merchantID.length > 1) {
      newMerchantID = "*";
      newDataMerchantID = merchantID.toString();
    } else {
      newMerchantID = merchantID.toString();
    }
  } else if (typeof merchantID === "string" && merchantID.length > 0) {
    newMerchantID = merchantID;
  } else if (typeof dataMerchantID === "string" && dataMerchantID.length > 0) {
    newMerchantID = "*";
    newDataMerchantID = dataMerchantID;
  }

  return {
    "merchant-id": newMerchantID,
    "data-merchant-id": newDataMerchantID
  };
}
/**
 * Load the Paypal JS SDK script asynchronously.
 *
 * @param {Object} options - used to configure query parameters and data attributes for the JS SDK.
 * @param {PromiseConstructor} [PromisePonyfill=window.Promise] - optional Promise Constructor ponyfill.
 * @return {Promise<Object>} paypalObject - reference to the global window PayPal object.
 */


function loadScript(options) {
  var PromisePonyfill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getDefaultPromiseImplementation();
  validateArguments(options, PromisePonyfill); // resolve with null when running in Node

  if (typeof window === "undefined") return PromisePonyfill.resolve(null);

  var _processOptions = processOptions(options),
      url = _processOptions.url,
      dataAttributes = _processOptions.dataAttributes;

  var namespace = dataAttributes["data-namespace"] || "paypal";
  var existingWindowNamespace = getPayPalWindowNamespace$1(namespace); // resolve with the existing global paypal namespace when a script with the same params already exists

  if (findScript(url, dataAttributes) && existingWindowNamespace) {
    return PromisePonyfill.resolve(existingWindowNamespace);
  }

  return loadCustomScript({
    url: url,
    attributes: dataAttributes
  }, PromisePonyfill).then(function () {
    var newWindowNamespace = getPayPalWindowNamespace$1(namespace);

    if (newWindowNamespace) {
      return newWindowNamespace;
    }

    throw new Error("The window.".concat(namespace, " global variable is not available."));
  });
}
/**
 * Load a custom script asynchronously.
 *
 * @param {Object} options - used to set the script url and attributes.
 * @param {PromiseConstructor} [PromisePonyfill=window.Promise] - optional Promise Constructor ponyfill.
 * @return {Promise<void>} returns a promise to indicate if the script was successfully loaded.
 */


function loadCustomScript(options) {
  var PromisePonyfill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getDefaultPromiseImplementation();
  validateArguments(options, PromisePonyfill);
  var url = options.url,
      attributes = options.attributes;

  if (typeof url !== "string" || url.length === 0) {
    throw new Error("Invalid url.");
  }

  if (typeof attributes !== "undefined" && _typeof(attributes) !== "object") {
    throw new Error("Expected attributes to be an object.");
  }

  return new PromisePonyfill(function (resolve, reject) {
    // resolve with undefined when running in Node
    if (typeof window === "undefined") return resolve();
    insertScriptElement({
      url: url,
      attributes: attributes,
      onSuccess: function onSuccess() {
        return resolve();
      },
      onError: function onError() {
        return reject(new Error("The script \"".concat(url, "\" failed to load.")));
      }
    });
  });
}

function getDefaultPromiseImplementation() {
  if (typeof Promise === "undefined") {
    throw new Error("Promise is undefined. To resolve the issue, use a Promise polyfill.");
  }

  return Promise;
}

function getPayPalWindowNamespace$1(namespace) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return window[namespace];
}

function validateArguments(options, PromisePonyfill) {
  if (_typeof(options) !== "object" || options === null) {
    throw new Error("Expected an options object.");
  }

  if (typeof PromisePonyfill !== "undefined" && typeof PromisePonyfill !== "function") {
    throw new Error("Expected PromisePonyfill to be a function.");
  }
}

var SCRIPT_LOADING_STATE;

(function (SCRIPT_LOADING_STATE) {
  SCRIPT_LOADING_STATE["INITIAL"] = "initial";
  SCRIPT_LOADING_STATE["PENDING"] = "pending";
  SCRIPT_LOADING_STATE["REJECTED"] = "rejected";
  SCRIPT_LOADING_STATE["RESOLVED"] = "resolved";
})(SCRIPT_LOADING_STATE || (SCRIPT_LOADING_STATE = {}));

var ScriptContext = createContext(null);
var ScriptDispatchContext = createContext(null);

function scriptReducer(state, action) {
  switch (action.type) {
    case "setLoadingStatus":
      return {
        options: _objectSpread({}, state.options),
        loadingStatus: action.value
      };

    case "resetOptions":
      // destroy existing script to make sure only one script loads at a time
      destroySDKScript(state.options["data-react-paypal-script-id"]);
      return {
        loadingStatus: SCRIPT_LOADING_STATE.PENDING,
        options: _objectSpread(_objectSpread({}, action.value), {}, {
          "data-react-paypal-script-id": "".concat(getNewScriptID())
        })
      };

    default:
      {
        return state;
      }
  }
}

function getNewScriptID() {
  return "react-paypal-js-".concat(Math.random().toString(36).substring(7));
}

function destroySDKScript(reactPayPalScriptID) {
  var scriptNode = document.querySelector("script[data-react-paypal-script-id=\"".concat(reactPayPalScriptID, "\"]"));
  if (scriptNode === null) return;

  if (scriptNode.parentNode) {
    scriptNode.parentNode.removeChild(scriptNode);
  }
}

function usePayPalScriptReducer() {
  var scriptContext = useContext(ScriptContext);
  var dispatchContext = useContext(ScriptDispatchContext);

  if (scriptContext === null || dispatchContext === null) {
    throw new Error("usePayPalScriptReducer must be used within a PayPalScriptProvider");
  }

  var loadingStatus = scriptContext.loadingStatus,
      restScriptContext = _objectWithoutProperties(scriptContext, ["loadingStatus"]);

  var derivedStatusContext = _objectSpread(_objectSpread({}, restScriptContext), {}, {
    isInitial: loadingStatus === SCRIPT_LOADING_STATE.INITIAL,
    isPending: loadingStatus === SCRIPT_LOADING_STATE.PENDING,
    isResolved: loadingStatus === SCRIPT_LOADING_STATE.RESOLVED,
    isRejected: loadingStatus === SCRIPT_LOADING_STATE.REJECTED
  });

  return [derivedStatusContext, dispatchContext];
}

var PayPalScriptProvider = function PayPalScriptProvider(_ref2) {
  var options = _ref2.options,
      children = _ref2.children,
      _ref2$deferLoading = _ref2.deferLoading,
      deferLoading = _ref2$deferLoading === void 0 ? false : _ref2$deferLoading;
  var initialState = {
    options: _objectSpread(_objectSpread({}, options), {}, {
      "data-react-paypal-script-id": "".concat(getNewScriptID())
    }),
    loadingStatus: deferLoading ? SCRIPT_LOADING_STATE.INITIAL : SCRIPT_LOADING_STATE.PENDING
  };

  var _useReducer = useReducer(scriptReducer, initialState),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      state = _useReducer2[0],
      dispatch = _useReducer2[1];

  useEffect(function () {
    if (deferLoading === false && state.loadingStatus === SCRIPT_LOADING_STATE.INITIAL) {
      return dispatch({
        type: "setLoadingStatus",
        value: SCRIPT_LOADING_STATE.PENDING
      });
    }

    if (state.loadingStatus !== SCRIPT_LOADING_STATE.PENDING) return;
    var isSubscribed = true;
    loadScript(state.options).then(function () {
      if (isSubscribed) {
        dispatch({
          type: "setLoadingStatus",
          value: SCRIPT_LOADING_STATE.RESOLVED
        });
      }
    })["catch"](function () {
      if (isSubscribed) {
        dispatch({
          type: "setLoadingStatus",
          value: SCRIPT_LOADING_STATE.REJECTED
        });
      }
    });
    return function () {
      isSubscribed = false;
    };
  }, [options, deferLoading, state.loadingStatus]);
  return React.createElement(ScriptContext.Provider, {
    value: state
  }, React.createElement(ScriptDispatchContext.Provider, {
    value: dispatch
  }, children));
};

var DEFAULT_PAYPAL_NAMESPACE = "paypal";

function getPayPalWindowNamespace() {
  var namespace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_PAYPAL_NAMESPACE;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return window[namespace];
}
/**
 * This `<PayPalButtons />` component renders the [Smart Payment Buttons](https://developer.paypal.com/docs/business/javascript-sdk/javascript-sdk-reference/#buttons).
 * It relies on the `<PayPalScriptProvider />` parent component for managing state related to loading the JS SDK script.
 *
 * Use props for customizing your buttons. For example, here's how you would use the `style` and `createOrder` options:
 *
 * ```jsx
 *     <PayPalButtons style={{ layout: "vertical" }} createOrder={(data, actions) => {}} />
 * ```
 */


var PayPalButtons = function PayPalButtons(_ref3) {
  var _ref3$className = _ref3.className,
      className = _ref3$className === void 0 ? "" : _ref3$className,
      _ref3$disabled = _ref3.disabled,
      disabled = _ref3$disabled === void 0 ? false : _ref3$disabled,
      _ref3$children = _ref3.children,
      children = _ref3$children === void 0 ? null : _ref3$children,
      _ref3$forceReRender = _ref3.forceReRender,
      forceReRender = _ref3$forceReRender === void 0 ? [] : _ref3$forceReRender,
      buttonProps = _objectWithoutProperties(_ref3, ["className", "disabled", "children", "forceReRender"]);

  var buttonsContainerRef = useRef(null);
  var buttons = useRef(null);

  var _usePayPalScriptReduc = usePayPalScriptReducer(),
      _usePayPalScriptReduc2 = _slicedToArray(_usePayPalScriptReduc, 1),
      _usePayPalScriptReduc3 = _usePayPalScriptReduc2[0],
      isResolved = _usePayPalScriptReduc3.isResolved,
      options = _usePayPalScriptReduc3.options;

  var _useState = useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      initActions = _useState2[0],
      setInitActions = _useState2[1];

  var _useState3 = useState(true),
      _useState4 = _slicedToArray(_useState3, 2),
      isEligible = _useState4[0],
      setIsEligible = _useState4[1];

  var _useState5 = useState(null),
      _useState6 = _slicedToArray(_useState5, 2),
      setErrorState = _useState6[1];

  function closeButtonsComponent() {
    if (buttons.current !== null) {
      buttons.current.close()["catch"](function () {// ignore errors when closing the component
      });
    }
  } // useEffect hook for rendering the buttons


  useEffect(function () {
    // verify the sdk script has successfully loaded
    if (isResolved === false) {
      return closeButtonsComponent;
    }

    var paypalWindowNamespace = getPayPalWindowNamespace(options["data-namespace"]); // verify dependency on window object

    if (paypalWindowNamespace === undefined || paypalWindowNamespace.Buttons === undefined) {
      setErrorState(function () {
        throw new Error(getErrorMessage$2(options));
      });
      return closeButtonsComponent;
    }

    var decoratedOnInit = function decoratedOnInit(data, actions) {
      setInitActions(actions);

      if (typeof buttonProps.onInit === "function") {
        buttonProps.onInit(data, actions);
      }
    };

    buttons.current = paypalWindowNamespace.Buttons(_objectSpread(_objectSpread({}, buttonProps), {}, {
      onInit: decoratedOnInit
    })); // only render the button when eligible

    if (buttons.current.isEligible() === false) {
      setIsEligible(false);
      return closeButtonsComponent;
    }

    if (buttonsContainerRef.current === null) {
      return closeButtonsComponent;
    }

    buttons.current.render(buttonsContainerRef.current)["catch"](function (err) {
      // component failed to render, possibly because it was closed or destroyed.
      if (buttonsContainerRef.current === null || buttonsContainerRef.current.children.length === 0) {
        // paypal buttons container is no longer in the DOM, we can safely ignore the error
        return;
      } // paypal buttons container is still in the DOM


      setErrorState(function () {
        throw new Error("Failed to render <PayPalButtons /> component. ".concat(err));
      });
    });
    return closeButtonsComponent;
  }, [isResolved].concat(_toConsumableArray(forceReRender), [buttonProps.fundingSource])); // useEffect hook for managing disabled state

  useEffect(function () {
    if (initActions === null) {
      return;
    }

    if (disabled === true) {
      initActions.disable()["catch"](function () {// ignore errors when disabling the component
      });
    } else {
      initActions.enable()["catch"](function () {// ignore errors when enabling the component
      });
    }
  }, [disabled, initActions]);
  var isDisabledStyle = disabled ? {
    opacity: 0.33
  } : {};
  var classNames = "".concat(className, " ").concat(disabled ? "paypal-buttons-disabled" : "").trim();

  if (isEligible === false) {
    return children;
  }

  return React.createElement("div", {
    ref: buttonsContainerRef,
    style: isDisabledStyle,
    className: classNames
  });
};

function getErrorMessage$2(_ref4) {
  var _ref4$components = _ref4.components,
      components = _ref4$components === void 0 ? "" : _ref4$components,
      _ref4$dataNamespace = _ref4["data-namespace"],
      dataNamespace = _ref4$dataNamespace === void 0 ? DEFAULT_PAYPAL_NAMESPACE : _ref4$dataNamespace;
  var errorMessage = "Unable to render <PayPalButtons /> because window.".concat(dataNamespace, ".Buttons is undefined."); // the JS SDK includes the Buttons component by default when no 'components' are specified.
  // The 'buttons' component must be included in the 'components' list when using it with other components.

  if (components.length && !components.includes("buttons")) {
    var expectedComponents = "".concat(components, ",buttons");
    errorMessage += "\nTo fix the issue, add 'buttons' to the list of components passed to the parent PayPalScriptProvider:" + "\n`<PayPalScriptProvider options={{ components: '".concat(expectedComponents, "'}}>`.");
  }

  return errorMessage;
}
/**
 * The `<PayPalMarks />` component is used for conditionally rendering different payment options using radio buttons.
 * The [Display PayPal Buttons with other Payment Methods guide](https://developer.paypal.com/docs/business/checkout/add-capabilities/buyer-experience/#display-paypal-buttons-with-other-payment-methods) describes this style of integration in detail.
 * It relies on the `<PayPalScriptProvider />` parent component for managing state related to loading the JS SDK script.
 *
 * ```jsx
 *     <PayPalMarks />
 * ```
 *
 * This component can also be configured to use a single funding source similar to the [standalone buttons](https://developer.paypal.com/docs/business/checkout/configure-payments/standalone-buttons/) approach.
 * A `FUNDING` object is exported by this library which has a key for every available funding source option.
 *
 * ```js
 *     import { FUNDING } from '@paypal/react-paypal-js'
 * ```
 *
 * Use this `FUNDING` constant to set the `fundingSource` prop.
 *
 * ```jsx
 *     <PayPalMarks fundingSource={FUNDING.PAYPAL}/>
 * ```
 */


var PayPalMarks = function PayPalMarks(_ref5) {
  var _ref5$className = _ref5.className,
      className = _ref5$className === void 0 ? "" : _ref5$className,
      markProps = _objectWithoutProperties(_ref5, ["className"]);

  var _usePayPalScriptReduc4 = usePayPalScriptReducer(),
      _usePayPalScriptReduc5 = _slicedToArray(_usePayPalScriptReduc4, 1),
      _usePayPalScriptReduc6 = _usePayPalScriptReduc5[0],
      isResolved = _usePayPalScriptReduc6.isResolved,
      options = _usePayPalScriptReduc6.options;

  var markContainerRef = useRef(null);
  var mark = useRef(null);

  var _useState7 = useState(null),
      _useState8 = _slicedToArray(_useState7, 2),
      setErrorState = _useState8[1];

  useEffect(function () {
    // verify the sdk script has successfully loaded
    if (isResolved === false) {
      return;
    } // don't rerender when already rendered


    if (mark.current !== null) {
      return;
    }

    var paypalWindowNamespace = getPayPalWindowNamespace(options["data-namespace"]); // verify dependency on window object

    if (paypalWindowNamespace === undefined || paypalWindowNamespace.Marks === undefined) {
      setErrorState(function () {
        throw new Error(getErrorMessage$1(options));
      });
      return;
    }

    mark.current = paypalWindowNamespace.Marks(_objectSpread({}, markProps)); // only render the mark when eligible

    if (mark.current.isEligible() === false) {
      return;
    }

    if (markContainerRef.current === null) {
      return;
    }

    mark.current.render(markContainerRef.current)["catch"](function (err) {
      // component failed to render, possibly because it was closed or destroyed.
      if (markContainerRef.current === null || markContainerRef.current.children.length === 0) {
        // paypal marks container is no longer in the DOM, we can safely ignore the error
        return;
      } // paypal marks container is still in the DOM


      setErrorState(function () {
        throw new Error("Failed to render <PayPalMarks /> component. ".concat(err));
      });
    });
  }, [isResolved, markProps.fundingSource]);
  return React.createElement("div", {
    ref: markContainerRef,
    className: className
  });
};

function getErrorMessage$1(_ref6) {
  var _ref6$components = _ref6.components,
      components = _ref6$components === void 0 ? "" : _ref6$components,
      _ref6$dataNamespace = _ref6["data-namespace"],
      dataNamespace = _ref6$dataNamespace === void 0 ? DEFAULT_PAYPAL_NAMESPACE : _ref6$dataNamespace;
  var errorMessage = "Unable to render <PayPalMarks /> because window.".concat(dataNamespace, ".Marks is undefined."); // the JS SDK does not load the Marks component by default. It must be passed into the "components" query parameter.

  if (!components.includes("marks")) {
    var expectedComponents = components ? "".concat(components, ",marks") : "marks";
    errorMessage += "\nTo fix the issue, add 'marks' to the list of components passed to the parent PayPalScriptProvider:" + "\n`<PayPalScriptProvider options={{ components: '".concat(expectedComponents, "'}}>`.");
  }

  return errorMessage;
}

var PayPalMessages = function PayPalMessages(_ref7) {
  var _ref7$className = _ref7.className,
      className = _ref7$className === void 0 ? "" : _ref7$className,
      _ref7$forceReRender = _ref7.forceReRender,
      forceReRender = _ref7$forceReRender === void 0 ? [] : _ref7$forceReRender,
      messageProps = _objectWithoutProperties(_ref7, ["className", "forceReRender"]);

  var _usePayPalScriptReduc7 = usePayPalScriptReducer(),
      _usePayPalScriptReduc8 = _slicedToArray(_usePayPalScriptReduc7, 1),
      _usePayPalScriptReduc9 = _usePayPalScriptReduc8[0],
      isResolved = _usePayPalScriptReduc9.isResolved,
      options = _usePayPalScriptReduc9.options;

  var messagesContainerRef = useRef(null);
  var messages = useRef(null);

  var _useState9 = useState(null),
      _useState10 = _slicedToArray(_useState9, 2),
      setErrorState = _useState10[1];

  useEffect(function () {
    // verify the sdk script has successfully loaded
    if (isResolved === false) {
      return;
    }

    var paypalWindowNamespace = getPayPalWindowNamespace(options["data-namespace"]); // verify dependency on window object

    if (paypalWindowNamespace === undefined || paypalWindowNamespace.Messages === undefined) {
      setErrorState(function () {
        throw new Error(getErrorMessage(options));
      });
      return;
    }

    messages.current = paypalWindowNamespace.Messages(_objectSpread({}, messageProps));

    if (messagesContainerRef.current === null) {
      return;
    }

    messages.current.render(messagesContainerRef.current)["catch"](function (err) {
      // component failed to render, possibly because it was closed or destroyed.
      if (messagesContainerRef.current === null || messagesContainerRef.current.children.length === 0) {
        // paypal messages container is no longer in the DOM, we can safely ignore the error
        return;
      } // paypal messages container is still in the DOM


      setErrorState(function () {
        throw new Error("Failed to render <PayPalMessages /> component. ".concat(err));
      });
    });
  }, [isResolved].concat(_toConsumableArray(forceReRender)));
  return React.createElement("div", {
    ref: messagesContainerRef,
    className: className
  });
};

function getErrorMessage(_ref8) {
  var _ref8$components = _ref8.components,
      components = _ref8$components === void 0 ? "" : _ref8$components,
      _ref8$dataNamespace = _ref8["data-namespace"],
      dataNamespace = _ref8$dataNamespace === void 0 ? DEFAULT_PAYPAL_NAMESPACE : _ref8$dataNamespace;
  var errorMessage = "Unable to render <PayPalMessages /> because window.".concat(dataNamespace, ".Messages is undefined."); // the JS SDK does not load the Messages component by default. It must be passed into the "components" query parameter.

  if (!components.includes("messages")) {
    var expectedComponents = components ? "".concat(components, ",messages") : "messages";
    errorMessage += "\nTo fix the issue, add 'messages' to the list of components passed to the parent PayPalScriptProvider:" + "\n`<PayPalScriptProvider options={{ components: '".concat(expectedComponents, "'}}>`.");
  }

  return errorMessage;
}

var FUNDING = {
  PAYPAL: 'paypal',
  VENMO: 'venmo',
  APPLEPAY: 'applepay',
  ITAU: 'itau',
  CREDIT: 'credit',
  PAYLATER: 'paylater',
  CARD: 'card',
  IDEAL: 'ideal',
  SEPA: 'sepa',
  BANCONTACT: 'bancontact',
  GIROPAY: 'giropay',
  SOFORT: 'sofort',
  EPS: 'eps',
  MYBANK: 'mybank',
  P24: 'p24',
  VERKKOPANKKI: 'verkkopankki',
  PAYU: 'payu',
  BLIK: 'blik',
  TRUSTLY: 'trustly',
  ZIMPLER: 'zimpler',
  MAXIMA: 'maxima',
  OXXO: 'oxxo',
  BOLETO: 'boleto',
  WECHATPAY: 'wechatpay',
  MERCADOPAGO: 'mercadopago'
};
export { FUNDING, PayPalButtons, PayPalMarks, PayPalMessages, PayPalScriptProvider, usePayPalScriptReducer };
